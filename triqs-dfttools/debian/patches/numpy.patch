--- a/python/converters/hk_converter.py
+++ b/python/converters/hk_converter.py
@@ -172,7 +172,7 @@
 
             # Initialise the projectors:
             proj_mat = numpy.zeros([n_k, n_spin_blocs, n_corr_shells, max(
-                [crsh['dim'] for crsh in corr_shells]), max(n_orbitals)], numpy.complex_)
+                [crsh['dim'] for crsh in corr_shells]), numpy.max(n_orbitals)], numpy.complex_)
 
             # Read the projectors from the file:
             for ik in range(n_k):
@@ -195,8 +195,8 @@
             # now define the arrays for weights and hopping ...
             # w(k_index),  default normalisation
             bz_weights = numpy.ones([n_k], numpy.float_) / float(n_k)
-            hopping = numpy.zeros([n_k, n_spin_blocs, max(
-                n_orbitals), max(n_orbitals)], numpy.complex_)
+            hopping = numpy.zeros([n_k, n_spin_blocs, numpy.max(
+                n_orbitals), numpy.max(n_orbitals)], numpy.complex_)
 
             if (weights_in_file):
                 # weights in the file
--- a/python/converters/wien2k_converter.py
+++ b/python/converters/wien2k_converter.py
@@ -315,7 +315,7 @@
 
         # Initialise P, here a double list of matrices:
         proj_mat_all = numpy.zeros([self.n_k, self.n_spin_blocs, self.n_shells, max(
-            n_parproj), max([sh['dim'] for sh in self.shells]), max(self.n_orbitals)], numpy.complex_)
+            n_parproj), max([sh['dim'] for sh in self.shells]), numpy.max(self.n_orbitals)], numpy.complex_)
 
         rot_mat_all = [numpy.identity(
             self.shells[ish]['dim'], numpy.complex_) for ish in range(self.n_shells)]
--- a/python/sumk_dft_tools.py
+++ b/python/sumk_dft_tools.py
@@ -770,8 +770,8 @@
                         for iL in g.indices:
                             for iR in g.indices:
                                 for iom in xrange(n_om):
-                                    g.data[iom, iL, iR] = Sigma_save[
-                                        i].data[ioffset + iom, iL, iR]
+                                    g.data[iom, int(iL), int(iR)] = Sigma_save[
+                                        i].data[ioffset + iom, int(iL), int(iR)]
         else:
             assert n_om is not None, "transport_distribution: Number of omega points (n_om) needed to calculate transport distribution!"
             assert energy_window is not None, "transport_distribution: Energy window needed to calculate transport distribution!"
@@ -844,7 +844,7 @@
                                     continue
 
                                 self.Gamma_w[direction][iq, iw] += (numpy.dot(numpy.dot(numpy.dot(vel_R[v_i, v_i, dir_to_int[direction[0]]],
-                                                                                                  A_kw[isp][A_i, A_i, iw + iOm_mesh[iq]]), vel_R[v_i, v_i, dir_to_int[direction[1]]]),
+                                                                                                  A_kw[isp][A_i, A_i, int(iw + iOm_mesh[iq])]), vel_R[v_i, v_i, dir_to_int[direction[1]]]),
                                                                               A_kw[isp][A_i, A_i, iw]).trace().real * self.bz_weights[ik])
 
         for direction in self.directions:
